package multichat.chat.step07;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.StringTokenizer;
import java.util.Vector;

public class User {
	Socket client;
	ChatServerView serverView;
	InputStream is;
	InputStreamReader ir;
	BufferedReader br;
	
	OutputStream os;
	PrintWriter pw;
	
	String ip;
	
	//3. ---- user객체에 기존 사용자의 정보를 액세스할 수 있또록 변수 정의
	Vector<User> userlist;
	
	public User(Socket client, ChatServerView serverView, Vector<User> userlist) {
		super();
		this.client = client;
		this.serverView = serverView;
		this.userlist = userlist;
	}
	
	//2. ---- 채팅하는 사용자들의 목록을 JList에 추가(nickname)하기위한 변수 ----
	Vector<String> nicknamelist = new Vector<String>();
	StringTokenizer st;
	
	public void ioWork() {
		
		try {
			System.out.println("nickname:"+nickname);
			serverView.taclientlist.append("**********"+ nickname +"님이 입장**********");
			
			//6. 새로운 클라이언트가 입장을 하면 벡터에 저장되어있는 모든 클라이언트에게 입장을 알리는 메시지를 보내
			int size = userlist.size();
			for(int i=0; i<size; i++) {
				User user = userlist.get(i);
				user.sendMsg("new/"+nickname);	// 이미 접속한 사용자들한테 안내 - 새로 접속한 사용자의 nickname을 보낸다. 
			
			}
			//8. 접속자 리스트에 현재 새로 접속한 클라이언트 정보도 저장
			userlist.add(this);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	//7. ---- 클라이언트에게 메시지를 보내는 메소드 정의 ----
	public void sendMsg(String message) {
		pw.println(message);
	}
	//==========================================
	public void run() {
		while(true) {
			try {
				String msg = br.readLine();
				serverView.
				
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
		}
	}
}
